// This file is auto-generated by @hey-api/openapi-ts

export type Features = {
    [key: string]: (boolean);
};

export type FeatureFlags = {
    [key: string]: (boolean | string);
};

export type ComputeUnit = number;

/**
 * The Neon compute provisioner.
 * Specify the `k8s-neonvm` provisioner to create a compute endpoint that supports Autoscaling.
 *
 * Provisioner can be one of the following values:
 * * k8s-pod
 * * k8s-neonvm
 *
 * Clients must expect, that any string value that is not documented in the description above should be treated as a error. UNKNOWN value if safe to treat as an error too.
 *
 */
export type Provisioner = string;

export type PaginationResponse = {
    pagination?: Pagination;
};

/**
 * Cursor based pagination is used. The user must pass the cursor as is to the backend.
 * For more information about cursor based pagination, see
 * https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
 *
 */
export type Pagination = {
    cursor: string;
};

/**
 * Empty response.
 */
export type EmptyResponse = {
    [key: string]: unknown;
};

/**
 * Add a new JWKS to a specific endpoint of a project
 */
export type AddProjectJWKSRequest = {
    /**
     * The URL that lists the JWKS
     */
    jwks_url: string;
    /**
     * The name of the authentication provider (e.g., Clerk, Stytch, Auth0)
     */
    provider_name: string;
    /**
     * Branch ID
     */
    branch_id?: string;
    /**
     * The name of the required JWT Audience to be used
     */
    jwt_audience?: string;
    /**
     * The roles the JWKS should be mapped to
     */
    role_names: Array<(string)>;
};

export type JWKS = {
    /**
     * JWKS ID
     */
    id: string;
    /**
     * Project ID
     */
    project_id: string;
    /**
     * Branch ID
     */
    branch_id?: string;
    /**
     * The URL that lists the JWKS
     */
    jwks_url: string;
    /**
     * The name of the authentication provider (e.g., Clerk, Stytch, Auth0)
     */
    provider_name: string;
    /**
     * The date and time when the JWKS was created
     */
    created_at: string;
    /**
     * The date and time when the JWKS was last modified
     */
    updated_at: string;
    /**
     * The name of the required JWT Audience to be used
     */
    jwt_audience?: string;
};

/**
 * The list of configured JWKS definitions for a project
 */
export type ProjectJWKSResponse = {
    jwks: Array<JWKS>;
};

export type ApiKeyCreateRequest = {
    /**
     * A user-specified API key name. This value is required when creating an API key.
     */
    key_name: string;
};

export type OrgApiKeyCreateRequest = ApiKeyCreateRequest & {
    /**
     * If set, the API key can access only this project
     */
    project_id?: string;
};

export type ApiKeyCreateResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The generated 64-bit token required to access the Neon API
     */
    key: string;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A timestamp indicating when the API key was created
     */
    created_at: string;
    /**
     * ID of the user who created this API key
     */
    created_by: string;
};

export type OrgApiKeyCreateResponse = ApiKeyCreateResponse & {
    /**
     * If set, the API key can access only this project
     */
    project_id?: string;
};

export type ApiKeyRevokeResponse = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A timestamp indicating when the API key was created
     */
    created_at: string;
    /**
     * ID of the user who created this API key
     */
    created_by: string;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
    /**
     * A `true` or `false` value indicating whether the API key is revoked
     */
    revoked: boolean;
};

export type OrgApiKeyRevokeResponse = ApiKeyRevokeResponse & {
    /**
     * If set, the API key can access only this project
     */
    project_id?: string;
};

export type ApiKeysListResponseItem = {
    /**
     * The API key ID
     */
    id: number;
    /**
     * The user-specified API key name
     */
    name: string;
    /**
     * A timestamp indicating when the API key was created
     */
    created_at: string;
    created_by: ApiKeyCreatorData;
    /**
     * A timestamp indicating when the API was last used
     */
    last_used_at?: string | null;
    /**
     * The IP address from which the API key was last used
     */
    last_used_from_addr: string;
};

export type OrgApiKeysListResponseItem = ApiKeysListResponseItem & {
    /**
     * If set, the API key can access only this project
     */
    project_id?: string;
};

/**
 * The user data of the user that created this API key.
 */
export type ApiKeyCreatorData = {
    /**
     * ID of the user who created this API key
     */
    id: string;
    /**
     * The name of the user.
     */
    name: string;
    /**
     * The URL to the user's avatar image.
     */
    image: string;
};

export type Operation = {
    /**
     * The operation ID
     */
    id: string;
    /**
     * The Neon project ID
     */
    project_id: string;
    /**
     * The branch ID
     */
    branch_id?: string;
    /**
     * The endpoint ID
     */
    endpoint_id?: string;
    action: OperationAction;
    status: OperationStatus;
    /**
     * The error that occurred
     */
    error?: string;
    /**
     * The number of times the operation failed
     */
    failures_count: number;
    /**
     * A timestamp indicating when the operation was last retried
     */
    retry_at?: string;
    /**
     * A timestamp indicating when the operation was created
     */
    created_at: string;
    /**
     * A timestamp indicating when the operation status was last updated
     */
    updated_at: string;
    /**
     * The total duration of the operation in milliseconds
     */
    total_duration_ms: number;
};

export type OperationResponse = {
    operation: Operation;
};

export type OperationsResponse = {
    operations: Array<Operation>;
};

/**
 * The action performed by the operation
 */
export type OperationAction = 'create_compute' | 'create_timeline' | 'start_compute' | 'suspend_compute' | 'apply_config' | 'check_availability' | 'delete_timeline' | 'create_branch' | 'import_data' | 'tenant_ignore' | 'tenant_attach' | 'tenant_detach' | 'tenant_reattach' | 'replace_safekeeper' | 'disable_maintenance' | 'apply_storage_config' | 'prepare_secondary_pageserver' | 'switch_pageserver' | 'detach_parent_branch' | 'timeline_archive' | 'timeline_unarchive' | 'start_reserved_compute' | 'sync_dbs_and_roles_from_compute' | 'apply_schema_from_branch';

/**
 * The status of the operation
 */
export type OperationStatus = 'scheduling' | 'running' | 'finished' | 'failed' | 'error' | 'cancelling' | 'cancelled' | 'skipped';

/**
 * Essential data about the project. Full data is available at the getProject endpoint.
 *
 */
export type ProjectListItem = {
    /**
     * The project ID
     */
    id: string;
    /**
     * The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
     *
     */
    platform_id: string;
    /**
     * The region identifier
     *
     */
    region_id: string;
    /**
     * The project name
     *
     */
    name: string;
    provisioner: Provisioner;
    default_endpoint_settings?: DefaultEndpointSettings;
    settings?: ProjectSettingsData;
    pg_version: PgVersion;
    /**
     * The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
     *
     */
    proxy_host: string;
    /**
     * The logical size limit for a branch. The value is in MiB.
     *
     */
    branch_logical_size_limit: number;
    /**
     * The logical size limit for a branch. The value is in B.
     *
     */
    branch_logical_size_limit_bytes: number;
    /**
     * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
     *
     */
    store_passwords: boolean;
    /**
     * Control plane observed endpoints of this project being active this amount of wall-clock time.
     *
     */
    active_time: number;
    /**
     * DEPRECATED. Use data from the getProject endpoint instead.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    /**
     * A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
     *
     */
    maintenance_starts_at?: string;
    /**
     * The project creation source
     *
     */
    creation_source: string;
    /**
     * A timestamp indicating when the project was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the project was last updated
     *
     */
    updated_at: string;
    /**
     * The current space occupied by the project in storage, in bytes. Synthetic storage size combines the logical data size and Write-Ahead Log (WAL) size for all branches in a project.
     *
     */
    synthetic_storage_size?: number;
    /**
     * DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
     * A timestamp indicating when the project quota resets
     *
     * @deprecated
     */
    quota_reset_at?: string;
    owner_id: string;
    /**
     * The most recent time when any endpoint of this project was active.
     *
     * Omitted when observed no activity for endpoints of this project.
     *
     */
    compute_last_active_at?: string;
    /**
     * Organization id if a project belongs to organization.
     * Permissions for the project will be given to organization members as defined by the organization admins.
     * The permissions of the project do not depend on the user that created the project if a project belongs to an organization.
     *
     */
    org_id?: string;
};

export type Project = {
    /**
     * Bytes-Hour. Project consumed that much storage hourly during the billing period. The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    data_storage_bytes_hour: number;
    /**
     * Bytes. Egress traffic from the Neon cloud to the client for given project over the billing period.
     * Includes deleted endpoints. The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    data_transfer_bytes: number;
    /**
     * Bytes. Amount of WAL that travelled through storage for given project across all branches.
     * The value has some lag. The value is reset at the beginning of each billing period.
     *
     */
    written_data_bytes: number;
    /**
     * Seconds. The number of CPU seconds used by the project's compute endpoints, including compute endpoints that have been deleted.
     * The value has some lag. The value is reset at the beginning of each billing period.
     * Examples:
     * 1. An endpoint that uses 1 CPU for 1 second is equal to `compute_time=1`.
     * 2. An endpoint that uses 2 CPUs simultaneously for 1 second is equal to `compute_time=2`.
     *
     */
    compute_time_seconds: number;
    /**
     * Seconds. Control plane observed endpoints of this project being active this amount of wall-clock time.
     * The value has some lag.
     * The value is reset at the beginning of each billing period.
     *
     */
    active_time_seconds: number;
    /**
     * DEPRECATED, use compute_time instead.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    /**
     * The project ID
     */
    id: string;
    /**
     * The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
     *
     */
    platform_id: string;
    /**
     * The region identifier
     *
     */
    region_id: string;
    /**
     * The project name
     *
     */
    name: string;
    provisioner: Provisioner;
    default_endpoint_settings?: DefaultEndpointSettings;
    settings?: ProjectSettingsData;
    pg_version: PgVersion;
    /**
     * The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
     *
     */
    proxy_host: string;
    /**
     * The logical size limit for a branch. The value is in MiB.
     *
     */
    branch_logical_size_limit: number;
    /**
     * The logical size limit for a branch. The value is in B.
     *
     */
    branch_logical_size_limit_bytes: number;
    /**
     * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
     *
     */
    store_passwords: boolean;
    /**
     * A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
     *
     */
    maintenance_starts_at?: string;
    /**
     * The project creation source
     *
     */
    creation_source: string;
    /**
     * The number of seconds to retain the shared history for all branches in this project. The default for all plans is 1 day (86400 seconds).
     *
     */
    history_retention_seconds: number;
    /**
     * A timestamp indicating when the project was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the project was last updated
     *
     */
    updated_at: string;
    /**
     * The current space occupied by the project in storage, in bytes. Synthetic storage size combines the logical data size and Write-Ahead Log (WAL) size for all branches in a project.
     *
     */
    synthetic_storage_size?: number;
    /**
     * A date-time indicating when Neon Cloud started measuring consumption for current consumption period.
     *
     */
    consumption_period_start: string;
    /**
     * A date-time indicating when Neon Cloud plans to stop measuring consumption for current consumption period.
     *
     */
    consumption_period_end: string;
    /**
     * DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
     * A timestamp indicating when the project quota resets.
     *
     * @deprecated
     */
    quota_reset_at?: string;
    owner_id: string;
    owner?: ProjectOwnerData;
    /**
     * The most recent time when any endpoint of this project was active.
     *
     * Omitted when observed no activity for endpoints of this project.
     *
     */
    compute_last_active_at?: string;
    org_id?: string;
    /**
     * A timestamp indicating when project update begins. If set, computes might experience a brief restart around this time.
     *
     */
    maintenance_scheduled_for?: string;
};

export type ProjectCreateRequest = {
    project: {
        settings?: ProjectSettingsData;
        /**
         * The project name. If not specified, the name will be identical to the generated project ID
         */
        name?: string;
        branch?: {
            /**
             * The default branch name. If not specified, the default branch name, `main`, will be used.
             *
             */
            name?: string;
            /**
             * The role name. If not specified, the default role name, `{database_name}_owner`, will be used.
             *
             */
            role_name?: string;
            /**
             * The database name. If not specified, the default database name, `neondb`, will be used.
             *
             */
            database_name?: string;
        };
        /**
         * DEPRECATED, use default_endpoint_settings.autoscaling_limit_min_cu instead.
         *
         * The minimum number of Compute Units. The minimum value is `0.25`.
         * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         * @deprecated
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * DEPRECATED, use default_endpoint_settings.autoscaling_limit_max_cu instead.
         *
         * The maximum number of Compute Units. See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         * @deprecated
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        /**
         * The region identifier. Refer to our [Regions](https://neon.tech/docs/introduction/regions) documentation for supported regions. Values are specified in this format: `aws-us-east-1`
         *
         */
        region_id?: string;
        default_endpoint_settings?: DefaultEndpointSettings;
        pg_version?: PgVersion;
        /**
         * Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
         *
         */
        store_passwords?: boolean;
        /**
         * The number of seconds to retain the shared history for all branches in this project.
         * The default is 1 day (86400 seconds).
         *
         */
        history_retention_seconds?: number;
        /**
         * Organization id in case the project created belongs to an organization.
         * If not present, project is owned by a user and not by org.
         *
         */
        org_id?: string;
    };
};

export type ProjectUpdateRequest = {
    project: {
        settings?: ProjectSettingsData;
        /**
         * The project name
         */
        name?: string;
        default_endpoint_settings?: DefaultEndpointSettings;
        /**
         * The number of seconds to retain the shared history for all branches in this project.
         * The default is 1 day (604800 seconds).
         *
         */
        history_retention_seconds?: number;
    };
};

export type ProjectSettingsData = {
    quota?: ProjectQuota;
    allowed_ips?: AllowedIps;
    /**
     * Sets wal_level=logical for all compute endpoints in this project.
     * All active endpoints will be suspended.
     * Once enabled, logical replication cannot be disabled.
     *
     */
    enable_logical_replication?: boolean;
    maintenance_window?: MaintenanceWindow;
    /**
     * When set, connections from the public internet
     * are disallowed. This supersedes the AllowedIPs list.
     * This parameter is under active development and its semantics may change in the future.
     *
     */
    block_public_connections?: boolean;
    /**
     * When set, connections using VPC endpoints are disallowed.
     * This parameter is under active development and its semantics may change in the future.
     *
     */
    block_vpc_connections?: boolean;
    audit_log_level?: ProjectAuditLogLevel;
};

export type ProjectResponse = {
    project: Project;
};

export type ProjectsResponse = {
    projects: Array<ProjectListItem>;
    /**
     * A list of project IDs indicating which projects are known to exist, but whose details could not
     * be fetched within the requested (or implicit) time limit
     *
     */
    unavailable_project_ids?: Array<(string)>;
};

export type ProjectPermission = {
    id: string;
    granted_to_email: string;
    granted_at: string;
    revoked_at?: string;
};

export type ProjectPermissions = {
    project_permissions: Array<ProjectPermission>;
};

export type GrantPermissionToProjectRequest = {
    email: string;
};

export type ConsumptionHistoryPerAccountResponse = {
    periods: Array<ConsumptionHistoryPerPeriod>;
};

export type ConsumptionHistoryPerProjectResponse = {
    projects: Array<ConsumptionHistoryPerProject>;
};

export type ConsumptionHistoryPerProject = {
    /**
     * The project ID
     */
    project_id: string;
    periods: Array<ConsumptionHistoryPerPeriod>;
};

export type ConsumptionHistoryPerPeriod = {
    /**
     * The ID assigned to the specified billing period.
     */
    period_id: string;
    /**
     * The billing plan applicable during the billing period.
     */
    period_plan: string;
    /**
     * The start date-time of the billing period.
     *
     */
    period_start: string;
    /**
     * The end date-time of the billing period, available for the past periods only.
     *
     */
    period_end?: string;
    consumption: Array<ConsumptionHistoryPerTimeframe>;
};

export type ConsumptionHistoryPerTimeframe = {
    /**
     * The specified start date-time for the reported consumption.
     *
     */
    timeframe_start: string;
    /**
     * The specified end date-time for the reported consumption.
     *
     */
    timeframe_end: string;
    /**
     * Seconds. The amount of time the compute endpoints have been active.
     *
     */
    active_time_seconds: number;
    /**
     * Seconds. The number of CPU seconds used by compute endpoints, including compute endpoints that have been deleted.
     *
     */
    compute_time_seconds: number;
    /**
     * Bytes. The amount of written data for all branches.
     *
     */
    written_data_bytes: number;
    /**
     * Bytes. The space occupied in storage. Synthetic storage size combines the logical data size and Write-Ahead Log (WAL) size for all branches.
     *
     */
    synthetic_storage_size_bytes: number;
    /**
     * Bytes-Hour. The amount of storage consumed hourly.
     *
     */
    data_storage_bytes_hour?: number;
};

export type ConsumptionHistoryGranularity = 'hourly' | 'daily' | 'monthly';

export type ProjectLimits = {
    limits: Limits;
    features: Features;
};

export type Limits = {
    active_time: number;
    max_projects: number;
    max_branches: number;
    max_protected_branches: number;
    max_autoscaling_cu: number;
    max_fixed_size_cu: number;
    cpu_seconds: number;
    max_compute_time_non_primary: number;
    max_active_endpoints: number;
    max_read_only_endpoints: number;
    max_allowed_ips: number;
    max_vpc_endpoints_per_region: number;
    max_monitoring_retention_hours: number;
    max_history_retention_seconds: number;
    min_autosuspend_seconds: number;
    max_data_transfer: number;
    min_idle_seconds_to_autoarchive: number;
    min_age_seconds_to_autoarchive: number;
    max_branch_roles: number;
    max_branch_databases: number;
    max_concurrent_scheduled_operation_chains_per_project: number;
    max_concurrent_executing_operation_chains_per_project: number;
    max_root_branches: number;
    max_import_size: number;
};

export type ProjectAuditLogLevel = 'hipaa';

export type Branch = {
    /**
     * The branch ID. This value is generated when a branch is created. A `branch_id` value has a `br` prefix. For example: `br-small-term-683261`.
     *
     */
    id: string;
    /**
     * The ID of the project to which the branch belongs
     *
     */
    project_id: string;
    /**
     * The `branch_id` of the parent branch
     *
     */
    parent_id?: string;
    /**
     * The Log Sequence Number (LSN) on the parent branch from which this branch was created
     *
     */
    parent_lsn?: string;
    /**
     * The point in time on the parent branch from which this branch was created
     *
     */
    parent_timestamp?: string;
    /**
     * The branch name
     *
     */
    name: string;
    current_state: BranchState;
    pending_state?: BranchState;
    /**
     * A UTC timestamp indicating when the `current_state` began
     *
     */
    state_changed_at: string;
    /**
     * The logical size of the branch, in bytes
     *
     */
    logical_size?: number;
    /**
     * The branch creation source
     *
     */
    creation_source: string;
    /**
     * DEPRECATED. Use `default` field.
     * Whether the branch is the project's primary branch
     *
     * @deprecated
     */
    primary?: boolean;
    /**
     * Whether the branch is the project's default branch
     *
     */
    default: boolean;
    /**
     * Whether the branch is protected
     *
     */
    protected: boolean;
    /**
     * CPU seconds used by all of the branch's compute endpoints, including deleted ones.
     * This value is reset at the beginning of each billing period.
     * Examples:
     * 1. A branch that uses 1 CPU for 1 second is equal to `cpu_used_sec=1`.
     * 2. A branch that uses 2 CPUs simultaneously for 1 second is equal to `cpu_used_sec=2`.
     *
     * @deprecated
     */
    cpu_used_sec: number;
    compute_time_seconds: number;
    active_time_seconds: number;
    written_data_bytes: number;
    data_transfer_bytes: number;
    /**
     * A timestamp indicating when the branch was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the branch was last updated
     *
     */
    updated_at: string;
    /**
     * A timestamp indicating when the branch was last reset
     *
     */
    last_reset_at?: string;
    /**
     * The resolved user model that contains details of the user/org/integration/api_key used for branch creation. This field is filled only in listing/get/create/get/update/delete methods, if it is empty when calling other handlers, it does not mean that it is empty in the system.
     *
     */
    created_by?: {
        /**
         * The name of the user.
         */
        name?: string;
        /**
         * The URL to the user's avatar image.
         */
        image?: string;
    };
    /**
     * The source of initialization for the branch. Valid values are `schema-only` and `parent-data` (default).
     * * `schema-only` - creates a new root branch containing only the schema. Use `parent_id` to specify the source branch. Optionally, you can provide `parent_lsn` or `parent_timestamp` to branch from a specific point in time or LSN. These fields define which branch to copy the schema from and at what point—they do not establish a parent-child relationship between the `parent_id` branch and the new schema-only branch.
     * * `parent-data` - creates the branch with both schema and data from the parent.
     *
     */
    init_source?: string;
};

/**
 * The branch’s state, indicating if it is initializing, ready for use, or archived.
 * * 'init' - the branch is being created but is not available for querying.
 * * 'ready' - the branch is fully operational and ready for querying. Expect normal query response times.
 * * 'archived' - the branch is stored in cost-effective archival storage. Expect slow query response times.
 *
 */
export type BranchState = string;

export type BranchCreateRequestEndpointOptions = {
    type: EndpointType;
    /**
     * The minimum number of Compute Units. The minimum value is `0.25`.
     * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
     * for more information.
     *
     */
    autoscaling_limit_min_cu?: ComputeUnit;
    /**
     * The maximum number of Compute Units.
     * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
     * for more information.
     *
     */
    autoscaling_limit_max_cu?: ComputeUnit;
    provisioner?: Provisioner;
    suspend_timeout_seconds?: SuspendTimeoutSeconds;
};

export type BranchCreateRequest = {
    endpoints?: Array<BranchCreateRequestEndpointOptions>;
    branch?: {
        /**
         * The `branch_id` of the parent branch. If omitted or empty, the branch will be created from the project's default branch.
         *
         */
        parent_id?: string;
        /**
         * The branch name
         *
         */
        name?: string;
        /**
         * A Log Sequence Number (LSN) on the parent branch. The branch will be created with data from this LSN.
         *
         */
        parent_lsn?: string;
        /**
         * A timestamp identifying a point in time on the parent branch. The branch will be created with data starting from this point in time.
         * The timestamp must be provided in ISO 8601 format; for example: `2024-02-26T12:00:00Z`.
         *
         */
        parent_timestamp?: string;
        /**
         * Whether the branch is protected
         *
         */
        protected?: boolean;
        /**
         * Whether to create the branch as archived
         *
         */
        archived?: boolean;
        /**
         * The source of initialization for the branch. Valid values are `schema-only` and `parent-data` (default).
         * * `schema-only` - creates a new root branch containing only the schema. Use `parent_id` to specify the source branch. Optionally, you can provide `parent_lsn` or `parent_timestamp` to branch from a specific point in time or LSN. These fields define which branch to copy the schema from and at what point—they do not establish a parent-child relationship between the `parent_id` branch and the new schema-only branch.
         * * `parent-data` - creates the branch with both schema and data from the parent.
         *
         */
        init_source?: string;
    };
};

export type BranchUpdateRequest = {
    branch: {
        name?: string;
        protected?: boolean;
    };
};

export type BranchRestoreRequest = {
    /**
     * The `branch_id` of the restore source branch.
     * If `source_timestamp` and `source_lsn` are omitted, the branch will be restored to head.
     * If `source_branch_id` is equal to the branch's id, `source_timestamp` or `source_lsn` is required.
     *
     */
    source_branch_id: string;
    /**
     * A Log Sequence Number (LSN) on the source branch. The branch will be restored with data from this LSN.
     *
     */
    source_lsn?: string;
    /**
     * A timestamp identifying a point in time on the source branch. The branch will be restored with data starting from this point in time.
     * The timestamp must be provided in ISO 8601 format; for example: `2024-02-26T12:00:00Z`.
     *
     */
    source_timestamp?: string;
    /**
     * If not empty, the previous state of the branch will be saved to a branch with this name.
     * If the branch has children or the `source_branch_id` is equal to the branch id, this field is required. All existing child branches will be moved to the newly created branch under the name `preserve_under_name`.
     *
     */
    preserve_under_name?: string;
};

export type BranchResponse = {
    branch: Branch;
};

export type BranchSchemaResponse = {
    sql?: string;
};

export type BranchSchemaCompareResponse = {
    diff?: string;
};

export type BranchesResponse = {
    branches: Array<Branch>;
};

export type BranchesCountResponse = {
    count: number;
};

export type ConnectionParameters = {
    /**
     * Database name
     *
     */
    database: string;
    /**
     * Password for the role
     *
     */
    password: string;
    /**
     * Role name
     *
     */
    role: string;
    /**
     * Hostname
     *
     */
    host: string;
    /**
     * Pooler hostname
     *
     */
    pooler_host: string;
};

export type ConnectionDetails = {
    /**
     * The connection URI is defined as specified here: [Connection URIs](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING-URIS)
     * The connection URI can be used to connect to a Postgres database with psql or defined in a DATABASE_URL environment variable.
     * When creating a branch from a parent with more than one role or database, the response body does not include a connection URI.
     *
     */
    connection_uri: string;
    connection_parameters: ConnectionParameters;
};

export type ConnectionURIResponse = {
    /**
     * The connection URI.
     *
     */
    uri: string;
};

export type Endpoint = {
    /**
     * The hostname of the compute endpoint. This is the hostname specified when connecting to a Neon database.
     *
     */
    host: string;
    /**
     * The compute endpoint ID. Compute endpoint IDs have an `ep-` prefix. For example: `ep-little-smoke-851426`
     *
     */
    id: string;
    /**
     * The ID of the project to which the compute endpoint belongs
     *
     */
    project_id: string;
    /**
     * The ID of the branch that the compute endpoint is associated with
     *
     */
    branch_id: string;
    /**
     * The minimum number of Compute Units
     *
     */
    autoscaling_limit_min_cu: ComputeUnit;
    /**
     * The maximum number of Compute Units
     *
     */
    autoscaling_limit_max_cu: ComputeUnit;
    /**
     * The region identifier
     *
     */
    region_id: string;
    type: EndpointType;
    current_state: EndpointState;
    pending_state?: EndpointState;
    settings: EndpointSettingsData;
    /**
     * Whether connection pooling is enabled for the compute endpoint
     *
     */
    pooler_enabled: boolean;
    pooler_mode: EndpointPoolerMode;
    /**
     * Whether to restrict connections to the compute endpoint.
     * Enabling this option schedules a suspend compute operation.
     * A disabled compute endpoint cannot be enabled by a connection or
     * console action. However, the compute endpoint is periodically
     * enabled by check_availability operations.
     *
     */
    disabled: boolean;
    /**
     * Whether to permit passwordless access to the compute endpoint
     *
     */
    passwordless_access: boolean;
    /**
     * A timestamp indicating when the compute endpoint was last active
     *
     */
    last_active?: string;
    /**
     * The compute endpoint creation source
     *
     */
    creation_source: string;
    /**
     * A timestamp indicating when the compute endpoint was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the compute endpoint was last updated
     *
     */
    updated_at: string;
    /**
     * DEPRECATED. Use the "host" property instead.
     *
     */
    proxy_host: string;
    suspend_timeout_seconds: SuspendTimeoutSeconds;
    provisioner: Provisioner;
    /**
     * Attached compute's release version number.
     *
     */
    compute_release_version?: string;
};

/**
 * The state of the compute endpoint
 *
 */
export type EndpointState = 'init' | 'active' | 'idle';

/**
 * The compute endpoint type. Either `read_write` or `read_only`.
 *
 */
export type EndpointType = 'read_only' | 'read_write';

/**
 * The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
 *
 */
export type EndpointPoolerMode = 'transaction';

/**
 * Duration of inactivity in seconds after which the compute endpoint is
 * automatically suspended. The value `0` means use the default value.
 * The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
 * The minimum value is `60` seconds (1 minute).
 * The maximum value is `604800` seconds (1 week). For more information, see
 * [Scale to zero configuration](https://neon.tech/docs/manage/endpoints#scale-to-zero-configuration).
 *
 */
export type SuspendTimeoutSeconds = number;

/**
 * A list of IP addresses that are allowed to connect to the compute endpoint.
 * If the list is empty or not set, all IP addresses are allowed.
 * If protected_branches_only is true, the list will be applied only to protected branches.
 *
 */
export type AllowedIps = {
    /**
     * A list of IP addresses that are allowed to connect to the endpoint.
     */
    ips?: Array<(string)>;
    /**
     * If true, the list will be applied only to protected branches.
     */
    protected_branches_only?: boolean;
};

/**
 * A maintenance window is a time period during which Neon may perform maintenance on the project's infrastructure.
 * During this time, the project's compute endpoints may be unavailable and existing connections can be
 * interrupted.
 *
 */
export type MaintenanceWindow = {
    /**
     * A list of weekdays when the maintenance window is active.
     * Encoded as ints, where 1 - Monday, and 7 - Sunday.
     *
     */
    weekdays: Array<(number)>;
    /**
     * Start time of the maintenance window, in the format of "HH:MM". Uses UTC.
     *
     */
    start_time: string;
    /**
     * End time of the maintenance window, in the format of "HH:MM". Uses UTC.
     *
     */
    end_time: string;
};

export type EndpointCreateRequest = {
    endpoint: {
        /**
         * The ID of the branch the compute endpoint will be associated with
         *
         */
        branch_id: string;
        /**
         * The region where the compute endpoint will be created. Only the project's `region_id` is permitted.
         *
         */
        region_id?: string;
        type: EndpointType;
        settings?: EndpointSettingsData;
        /**
         * The minimum number of Compute Units. The minimum value is `0.25`.
         * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * The maximum number of Compute Units.
         * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        /**
         * Whether to enable connection pooling for the compute endpoint
         *
         * @deprecated
         */
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Whether to restrict connections to the compute endpoint.
         * Enabling this option schedules a suspend compute operation.
         * A disabled compute endpoint cannot be enabled by a connection or
         * console action. However, the compute endpoint is periodically
         * enabled by check_availability operations.
         *
         */
        disabled?: boolean;
        /**
         * NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
         *
         */
        passwordless_access?: boolean;
        suspend_timeout_seconds?: SuspendTimeoutSeconds;
    };
};

export type EndpointUpdateRequest = {
    endpoint: {
        /**
         * DEPRECATED: This field will be removed in a future release.
         * The destination branch ID. The destination branch must not have an existing read-write endpoint.
         *
         * @deprecated
         */
        branch_id?: string;
        /**
         * The minimum number of Compute Units. The minimum value is `0.25`.
         * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         */
        autoscaling_limit_min_cu?: ComputeUnit;
        /**
         * The maximum number of Compute Units.
         * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
         * for more information.
         *
         */
        autoscaling_limit_max_cu?: ComputeUnit;
        provisioner?: Provisioner;
        settings?: EndpointSettingsData;
        /**
         * Whether to enable connection pooling for the compute endpoint
         *
         * @deprecated
         */
        pooler_enabled?: boolean;
        pooler_mode?: EndpointPoolerMode;
        /**
         * Whether to restrict connections to the compute endpoint.
         * Enabling this option schedules a suspend compute operation.
         * A disabled compute endpoint cannot be enabled by a connection or
         * console action. However, the compute endpoint is periodically
         * enabled by check_availability operations.
         *
         */
        disabled?: boolean;
        /**
         * NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
         *
         */
        passwordless_access?: boolean;
        suspend_timeout_seconds?: SuspendTimeoutSeconds;
    };
};

export type EndpointResponse = {
    endpoint: Endpoint;
};

export type ConnectionURIsResponse = {
    connection_uris: Array<ConnectionDetails>;
};

export type ConnectionURIsOptionalResponse = {
    connection_uris?: Array<ConnectionDetails>;
};

export type VPCEndpointsResponse = {
    endpoints: Array<VPCEndpoint>;
};

export type VPCEndpoint = {
    /**
     * The VPC endpoint ID
     */
    vpc_endpoint_id: string;
    /**
     * A descriptive label for the VPC endpoint
     */
    label: string;
};

export type VPCEndpointDetails = {
    /**
     * The VPC endpoint ID
     */
    vpc_endpoint_id: string;
    /**
     * A descriptive label for the VPC endpoint
     */
    label: string;
    /**
     * The current state of the VPC endpoint. Possible values are
     * `new` (just configured, pending acceptance) or `accepted`
     * (VPC connection was accepted by Neon).
     *
     */
    state: string;
    /**
     * The number of projects that are restricted to use this VPC endpoint.
     *
     */
    num_restricted_projects: number;
    /**
     * A list of example projects that are restricted to use this VPC endpoint.
     * There are at most 3 projects in the list, even if more projects are restricted.
     *
     */
    example_restricted_projects: Array<(string)>;
};

export type VPCEndpointAssignment = {
    label: string;
};

export type EndpointsResponse = {
    endpoints: Array<Endpoint>;
};

export type EndpointPasswordlessSessionAuthRequest = {
    session_id: string;
};

/**
 * A Duration represents the elapsed time between two instants
 * as an int64 nanosecond count. The representation limits the
 * largest representable duration to approximately 290 years.
 */
export type Duration = number;

export type StatementResult = {
    data?: StatementData;
    error?: string;
    explain_data?: Array<ExplainData>;
    query: string;
};

export type StatementData = {
    fields?: Array<(string)>;
    rows?: Array<Array<(string)>>;
    truncated: boolean;
};

export type ExplainData = {
    'QUERY PLAN': string;
};

export type Role = {
    /**
     * The ID of the branch to which the role belongs
     *
     */
    branch_id: string;
    /**
     * The role name
     *
     */
    name: string;
    /**
     * The role password
     *
     */
    password?: string;
    /**
     * Whether or not the role is system-protected
     *
     */
    protected?: boolean;
    /**
     * A timestamp indicating when the role was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the role was last updated
     *
     */
    updated_at: string;
};

export type RoleCreateRequest = {
    role: {
        /**
         * The role name. Cannot exceed 63 bytes in length.
         *
         */
        name: string;
        /**
         * Whether to create a role that cannot login.
         *
         */
        no_login?: boolean;
    };
};

export type RoleResponse = {
    role: Role;
};

export type JWKSResponse = {
    jwks: JWKS;
};

export type RolesResponse = {
    roles: Array<Role>;
};

export type RolePasswordResponse = {
    /**
     * The role password
     *
     */
    password: string;
};

export type PaymentSourceBankCard = {
    /**
     * Last 4 digits of the card.
     *
     */
    last4: string;
    /**
     * Brand of credit card.
     *
     */
    brand?: 'amex' | 'diners' | 'discover' | 'jcb' | 'mastercard' | 'unionpay' | 'unknown' | 'visa';
    /**
     * Credit card expiration month
     *
     */
    exp_month?: number;
    /**
     * Credit card expiration year
     *
     */
    exp_year?: number;
};

/**
 * Brand of credit card.
 *
 */
export type brand = 'amex' | 'diners' | 'discover' | 'jcb' | 'mastercard' | 'unionpay' | 'unknown' | 'visa';

export type PaymentSource = {
    /**
     * Type of payment source. E.g. "card".
     *
     */
    type: string;
    card?: PaymentSourceBankCard;
};

export type BillingAccount = {
    state: BillingAccountState;
    payment_source: PaymentSource;
    subscription_type: BillingSubscriptionType;
    payment_method: BillingPaymentMethod;
    /**
     * The last time the quota was reset. Defaults to the date-time the account is created.
     *
     */
    quota_reset_at_last: string;
    /**
     * The full name of the individual or entity that owns the billing account. This name appears on invoices.
     */
    name: string;
    /**
     * Billing email, to receive emails related to invoices and subscriptions.
     *
     */
    email: string;
    /**
     * Billing address city.
     *
     */
    address_city: string;
    /**
     * Billing address country code defined by ISO 3166-1 alpha-2.
     *
     */
    address_country: string;
    /**
     * Billing address country name.
     *
     */
    address_country_name?: string;
    /**
     * Billing address line 1.
     *
     */
    address_line1: string;
    /**
     * Billing address line 2.
     *
     */
    address_line2: string;
    /**
     * Billing address postal code.
     *
     */
    address_postal_code: string;
    /**
     * Billing address state or region.
     *
     */
    address_state: string;
    /**
     * Orb user portal url
     *
     */
    orb_portal_url?: string;
    /**
     * The tax identification number for the billing account, displayed on invoices.
     *
     */
    tax_id?: string;
    /**
     * The type of the tax identification number based on the country.
     *
     */
    tax_id_type?: string;
};

/**
 * State of the billing account.
 *
 */
export type BillingAccountState = 'UNKNOWN' | 'active' | 'suspended' | 'deactivated' | 'deleted';

/**
 * Type of subscription to Neon Cloud.
 * Notice that for users without billing account this will be "UNKNOWN"
 *
 */
export type BillingSubscriptionType = 'UNKNOWN' | 'direct_sales' | 'aws_marketplace' | 'free_v2' | 'launch' | 'scale' | 'business' | 'vercel_pg_legacy';

/**
 * Indicates whether and how an account makes payments.
 *
 */
export type BillingPaymentMethod = 'UNKNOWN' | 'none' | 'stripe' | 'direct_payment' | 'aws_mp' | 'azure_mp' | 'vercel_mp' | 'staff' | 'trial' | 'sponsorship';

export type Database = {
    /**
     * The database ID
     *
     */
    id: number;
    /**
     * The ID of the branch to which the database belongs
     *
     */
    branch_id: string;
    /**
     * The database name
     *
     */
    name: string;
    /**
     * The name of role that owns the database
     *
     */
    owner_name: string;
    /**
     * A timestamp indicating when the database was created
     *
     */
    created_at: string;
    /**
     * A timestamp indicating when the database was last updated
     *
     */
    updated_at: string;
};

export type DatabaseCreateRequest = {
    database: {
        /**
         * The name of the database
         *
         */
        name: string;
        /**
         * The name of the role that owns the database
         *
         */
        owner_name: string;
    };
};

export type DatabaseUpdateRequest = {
    database: {
        /**
         * The name of the database
         *
         */
        name?: string;
        /**
         * The name of the role that owns the database
         *
         */
        owner_name?: string;
    };
};

export type DatabaseResponse = {
    database: Database;
};

export type DatabasesResponse = {
    databases: Array<Database>;
};

export type Invitation = {
    id: string;
    /**
     * Email of the invited user
     */
    email: string;
    /**
     * Organization id as it is stored in Neon
     */
    org_id: string;
    /**
     * UUID for the user_id who extended the invitation
     */
    invited_by: string;
    /**
     * Timestamp when the invitation was created
     */
    invited_at: string;
    role: MemberRole;
};

/**
 * The role of the organization member
 */
export type MemberRole = 'admin' | 'member';

export type Member = {
    id: string;
    user_id: string;
    org_id: string;
    role: MemberRole;
    joined_at?: string;
};

export type MemberUserInfo = {
    email: string;
};

export type MemberWithUser = {
    member: Member;
    user: MemberUserInfo;
};

export type Organization = {
    id: string;
    name: string;
    handle: string;
    plan: string;
    /**
     * A timestamp indicting when the organization was created
     *
     */
    created_at: string;
    /**
     * Organizations created via the Console or the API are managed by `console`.
     * Organizations created by other methods can't be deleted via the Console or the API.
     *
     */
    managed_by: string;
    /**
     * A timestamp indicating when the organization was updated
     *
     */
    updated_at: string;
};

export type OrganizationsResponse = {
    organizations: Array<Organization>;
};

export type OrganizationsUpdateRequest = {
    name: string;
};

export type OrganizationInvitationsResponse = {
    invitations: Array<Invitation>;
};

export type OrganizationInviteCreateRequest = {
    email: string;
    role: MemberRole;
};

export type OrganizationInvitesCreateRequest = {
    invitations: Array<OrganizationInviteCreateRequest>;
};

export type OrganizationInviteUpdateRequest = {
    email?: string;
    role?: MemberRole;
    resend?: boolean;
};

/**
 * A list of details for guests of an organization
 *
 */
export type OrganizationGuestsResponse = Array<OrganizationGuest>;

/**
 * Details of an organization guest, who is not directly a member of
 * an organization but has been shared one of the projects it owns
 *
 */
export type OrganizationGuest = {
    permission_id: string;
    user_email: string;
    project_id: string;
    project_name: string;
};

export type OrganizationMemberUpdateRequest = {
    role: MemberRole;
};

export type OrganizationMembersResponse = {
    members: Array<MemberWithUser>;
};

export type InvitationCreateRequest = {
    /**
     * Email to invite
     */
    email: string;
    role: MemberRole;
};

export type OrganizationCreateRequest = {
    organization: {
        /**
         * The organization name
         */
        name?: string;
        /**
         * Emails with roles to invite to the organization
         */
        invitations?: Array<InvitationCreateRequest>;
    };
    subscription_type: BillingSubscriptionType;
};

export type OrganizationLimits = {
    limits: Limits;
    features: Features;
};

export type ActiveRegionsResponse = {
    /**
     * The list of active regions
     */
    regions: Array<RegionResponse>;
};

export type RegionResponse = {
    /**
     * The region ID as used in other API endpoints
     */
    region_id: string;
    /**
     * A short description of the region.
     */
    name: string;
    /**
     * Whether this region is used by default in new projects.
     */
    default: boolean;
    /**
     * The geographical latitude (approximate) for the region. Empty if unknown.
     */
    geo_lat: string;
    /**
     * The geographical longitude (approximate) for the region. Empty if unknown.
     */
    geo_long: string;
};

export type CurrentUserAuthAccount = {
    email: string;
    image: string;
    /**
     * DEPRECATED. Use `email` field.
     *
     * @deprecated
     */
    login: string;
    name: string;
    provider: IdentityProviderId;
};

export type LinkedAuthAccount = {
    provider: IdentityProviderId;
    provider_display_name: string;
    username: string;
};

export type UpdateUserInfoRequest = {
    email?: string;
    id: string;
    /**
     * DEPRECATED. This field is ignored.
     *
     * @deprecated
     */
    image?: string;
    first_name?: string;
    last_name?: string;
    password?: string;
    new_password?: string;
};

export type CurrentUserInfoResponse = {
    /**
     * Control plane observes active endpoints of a user this amount of wall-clock time.
     *
     */
    active_seconds_limit: number;
    billing_account: BillingAccount;
    auth_accounts: Array<CurrentUserAuthAccount>;
    email: string;
    id: string;
    image: string;
    /**
     * DEPRECATED. Use `email` field.
     *
     * @deprecated
     */
    login: string;
    name: string;
    last_name: string;
    projects_limit: number;
    branches_limit: number;
    max_autoscaling_limit: ComputeUnit;
    compute_seconds_limit?: number;
    plan: string;
};

export type ConvertUserToOrgRequest = {
    name: string;
};

export type CurrentUserInfoAuthResponse = {
    password_stored: boolean;
    auth_accounts: Array<CurrentUserAuthAccount>;
    linked_accounts: Array<LinkedAuthAccount>;
    provider: string;
};

export type TransferProjectsToOrganizationRequest = {
    /**
     * The destination organization identifier
     */
    destination_org_id: string;
    /**
     * The list of projects ids to transfer. Maximum of 400 project ids
     */
    project_ids: Array<(string)>;
};

export type VerifyUserPasswordRequest = {
    password: string;
};

/**
 * Identity provider id from keycloak
 */
export type IdentityProviderId = 'github' | 'google' | 'hasura' | 'microsoft' | 'microsoftv2' | 'vercelmp' | 'keycloak' | 'test';

/**
 * A collection of settings for a compute endpoint
 */
export type EndpointSettingsData = {
    pg_settings?: PgSettingsData;
    pgbouncer_settings?: PgbouncerSettingsData;
};

/**
 * Per-project consumption quota. If the quota is exceeded, all active computes
 * are automatically suspended and it will not be possible to start them with
 * an API method call or incoming proxy connections. The only exception is
 * `logical_size_bytes`, which is applied on per-branch basis, i.e., only the
 * compute on the branch that exceeds the `logical_size` quota will be suspended.
 *
 * Quotas are enforced based on per-project consumption metrics with the same names,
 * which are reset at the end of each billing period (the first day of the month).
 * Logical size is also an exception in this case, as it represents the total size
 * of data stored in a branch, so it is not reset.
 *
 * A zero or empty quota value means 'unlimited'.
 *
 */
export type ProjectQuota = {
    /**
     * The total amount of wall-clock time allowed to be spent by the project's compute endpoints.
     *
     */
    active_time_seconds?: number;
    /**
     * The total amount of CPU seconds allowed to be spent by the project's compute endpoints.
     *
     */
    compute_time_seconds?: number;
    /**
     * Total amount of data written to all of a project's branches.
     *
     */
    written_data_bytes?: number;
    /**
     * Total amount of data transferred from all of a project's branches using the proxy.
     *
     */
    data_transfer_bytes?: number;
    /**
     * Limit on the logical size of every project's branch.
     *
     */
    logical_size_bytes?: number;
};

/**
 * A collection of settings for a Neon endpoint
 */
export type DefaultEndpointSettings = {
    pg_settings?: PgSettingsData;
    pgbouncer_settings?: PgbouncerSettingsData;
    /**
     * The minimum number of Compute Units. The minimum value is `0.25`.
     * See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
     * for more information.
     *
     */
    autoscaling_limit_min_cu?: ComputeUnit;
    /**
     * The maximum number of Compute Units. See [Compute size and Autoscaling configuration](https://neon.tech/docs/manage/endpoints#compute-size-and-autoscaling-configuration)
     * for more information.
     *
     */
    autoscaling_limit_max_cu?: ComputeUnit;
    suspend_timeout_seconds?: SuspendTimeoutSeconds;
    [key: string]: (string | PgSettingsData | PgbouncerSettingsData | ComputeUnit | SuspendTimeoutSeconds) | undefined;
};

/**
 * A raw representation of Postgres settings
 */
export type PgSettingsData = {
    [key: string]: (string);
};

/**
 * A raw representation of PgBouncer settings
 */
export type PgbouncerSettingsData = {
    [key: string]: (string);
};

/**
 * The major Postgres version number. Currently supported versions are `14`, `15`, `16`, and `17`.
 */
export type PgVersion = number;

export type HealthCheck = {
    /**
     * Service status
     */
    status: string;
};

export type ProjectOwnerData = {
    email: string;
    name: string;
    branches_limit: number;
    subscription_type: BillingSubscriptionType;
};

export type LimitsUnsatisfiedResponse = {
    limits: Array<{
        name: string;
        expected: string;
        actual: string;
    }>;
};

export type ProjectsWithIntegrationResponse = {
    projects: Array<{
        id: string;
        integration: string;
    }>;
};

export type UserDeletionConditionName = 'project_count' | 'org_admin_membership_count' | 'subscription_type';

export type OrgDeletionConditionName = 'project_count';

export type IdentitySupportedAuthProvider = 'mock' | 'stack';

export type IdentityAuthProviderProjectOwnedBy = 'user' | 'neon';

export type IdentityAuthProviderProjectTransferStatus = 'initiated' | 'finished';

export type IdentityCreateIntegrationRequest = {
    auth_provider: IdentitySupportedAuthProvider;
    project_id: string;
    branch_id: string;
    database_name: string;
    role_name: string;
};

export type IdentityCreateIntegrationResponse = {
    auth_provider: IdentitySupportedAuthProvider;
    auth_provider_project_id: string;
    pub_client_key: string;
    secret_server_key: string;
    jwks_url: string;
    schema_name: string;
    table_name: string;
};

export type IdentityCreateAuthProviderSDKKeysRequest = {
    project_id: string;
    auth_provider: IdentitySupportedAuthProvider;
};

export type IdentityCreateNewUserRequest = {
    project_id: string;
    auth_provider: IdentitySupportedAuthProvider;
    email: string;
    name?: string;
};

export type IdentityCreateNewUserResponse = {
    /**
     * ID of newly created user
     */
    id: string;
};

export type IdentityTransferAuthProviderProjectRequest = {
    project_id: string;
    auth_provider: IdentitySupportedAuthProvider;
};

export type IdentityTransferAuthProviderProjectResponse = {
    /**
     * URL for completing the process of ownership transfer
     */
    url: string;
};

export type ListProjectIdentityIntegrationsResponse = {
    data: Array<IdentityIntegration>;
};

export type IdentityIntegration = {
    auth_provider: string;
    auth_provider_project_id: string;
    branch_id: string;
    db_name: string;
    created_at: string;
    owned_by: IdentityAuthProviderProjectOwnedBy;
    transfer_status?: IdentityAuthProviderProjectTransferStatus;
    jwks_url: string;
};

/**
 * General Error
 */
export type GeneralError = {
    request_id?: string;
    code: ErrorCode;
    /**
     * Error message
     */
    message: string;
};

export type ErrorCode = string;

export type BranchOperations = BranchResponse & OperationsResponse;

export type EndpointOperations = EndpointResponse & OperationsResponse;

export type DatabaseOperations = DatabaseResponse & OperationsResponse;

export type RoleOperations = RoleResponse & OperationsResponse;

export type JWKSCreationOperation = JWKSResponse & OperationsResponse;

export type SupportTicketSeverity = 'low' | 'normal' | 'high' | 'critical';

export type AnnotationData = {
    object: AnnotationObjectData;
    value: AnnotationValueData;
    created_at?: string;
    updated_at?: string;
};

/**
 * Annotation properties.
 */
export type AnnotationValueData = {
    [key: string]: (string);
};

export type AnnotationObjectData = {
    type: string;
    id: string;
};

export type AnnotationCreateValueRequest = {
    annotation_value?: AnnotationValueData;
};

export type AnnotationResponse = {
    annotation: AnnotationData;
};

export type AnnotationsMapResponse = {
    annotations: {
        [key: string]: AnnotationData;
    };
};

/**
 * A map where key is a project ID and a value is a list of installed applications.
 *
 */
export type ProjectsApplicationsMapResponse = {
    applications: {
        [key: string]: Array<('vercel' | 'github' | 'datadog')>;
    };
};

/**
 * A map where key is a project ID and a value is a list of installed integrations.
 *
 */
export type ProjectsIntegrationsMapResponse = {
    integrations: {
        [key: string]: Array<('vercel' | 'github' | 'datadog')>;
    };
};

export type CursorPaginationResponse = {
    pagination?: CursorPagination;
};

/**
 * To paginate the response, issue an initial request with `limit` value. Then, add the value returned in the response `.pagination.next` attribute into the request under the `cursor` query parameter to the subsequent request to retrieve next page in pagination. The contents on cursor `next` are opaque, clients are not expected to make any assumptions on the format of the data inside the cursor.
 */
export type CursorPagination = {
    next?: string;
    sort_by?: string;
    sort_order?: string;
};

export type Snapshot = {
    id: string;
    name: string;
    lsn?: string;
    timestamp?: string;
    source_branch_id?: string;
    source_schedule_id?: string;
    created_at: string;
    expires_at?: string;
};

/**
 * A cursor to use in pagination. A cursor defines your place in the data list. Include `response.pagination.next` in subsequent API calls to fetch next page of the list.
 */
export type ParameterCursorParam = string;

/**
 * The maximum number of records to be returned in the response
 */
export type ParameterLimitParam = number;

/**
 * Defines the sorting order of entities.
 */
export type ParameterSortOrderParam = 'asc' | 'desc';

/**
 * Specify an explicit timeout in milliseconds to limit response delay.
 * After timing out, the incomplete list of project data fetched so far will be returned.
 * Projects still being fetched when the timeout occurred are listed in the "unavailable" attribute of the response.
 * If not specified, an implicit implementation defined timeout is chosen with the same behaviour as above
 *
 */
export type ParameterTimeoutParam = number;

export type ListApiKeysResponse = Array<ApiKeysListResponseItem>;

export type CreateApiKeyData = {
    requestBody: ApiKeyCreateRequest;
};

export type CreateApiKeyResponse = ApiKeyCreateResponse;

export type RevokeApiKeyData = {
    /**
     * The API key ID
     */
    keyId: number;
};

export type RevokeApiKeyResponse = ApiKeyRevokeResponse;

export type GetProjectOperationData = {
    /**
     * The operation ID
     */
    operationId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectOperationResponse = OperationResponse;

export type ListProjectOperationsData = {
    /**
     * Specify the cursor value from the previous response to get the next batch of operations
     */
    cursor?: string;
    /**
     * Specify a value from 1 to 1000 to limit number of operations in the response
     */
    limit?: number;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectOperationsResponse = OperationsResponse & PaginationResponse;

export type ListProjectsData = {
    /**
     * Specify the cursor value from the previous response to retrieve the next batch of projects.
     */
    cursor?: string;
    /**
     * Specify a value from 1 to 400 to limit number of projects in the response.
     */
    limit?: number;
    /**
     * Search for projects by `org_id`.
     */
    orgId?: string;
    /**
     * Search by project `name` or `id`. You can specify partial `name` or `id` values to filter results.
     */
    search?: string;
    /**
     * Specify an explicit timeout in milliseconds to limit response delay.
     * After timing out, the incomplete list of project data fetched so far will be returned.
     * Projects still being fetched when the timeout occurred are listed in the "unavailable" attribute of the response.
     * If not specified, an implicit implementation defined timeout is chosen with the same behaviour as above
     *
     */
    timeout?: number;
};

export type ListProjectsResponse = ProjectsResponse & PaginationResponse & ProjectsApplicationsMapResponse & ProjectsIntegrationsMapResponse;

export type CreateProjectData = {
    requestBody: ProjectCreateRequest;
};

export type CreateProjectResponse = ProjectResponse & ConnectionURIsResponse & RolesResponse & DatabasesResponse & OperationsResponse & BranchResponse & EndpointsResponse;

export type ListSharedProjectsData = {
    /**
     * Specify the cursor value from the previous response to get the next batch of projects.
     */
    cursor?: string;
    /**
     * Specify a value from 1 to 400 to limit number of projects in the response.
     */
    limit?: number;
    /**
     * Search query by name or id.
     */
    search?: string;
    /**
     * Specify an explicit timeout in milliseconds to limit response delay.
     * After timing out, the incomplete list of project data fetched so far will be returned.
     * Projects still being fetched when the timeout occurred are listed in the "unavailable" attribute of the response.
     * If not specified, an implicit implementation defined timeout is chosen with the same behaviour as above
     *
     */
    timeout?: number;
};

export type ListSharedProjectsResponse = ProjectsResponse & PaginationResponse;

export type GetProjectData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectResponse = ProjectResponse;

export type UpdateProjectData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: ProjectUpdateRequest;
};

export type UpdateProjectResponse = ProjectResponse & OperationsResponse;

export type DeleteProjectData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectResponse = ProjectResponse;

export type ListProjectPermissionsData = {
    projectId: string;
};

export type ListProjectPermissionsResponse = ProjectPermissions;

export type GrantPermissionToProjectData = {
    projectId: string;
    requestBody: GrantPermissionToProjectRequest;
};

export type GrantPermissionToProjectResponse = ProjectPermission;

export type RevokePermissionFromProjectData = {
    permissionId: string;
    projectId: string;
};

export type RevokePermissionFromProjectResponse = ProjectPermission;

export type GetProjectJwksData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectJwksResponse = ProjectJWKSResponse;

export type AddProjectJwksData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: AddProjectJWKSRequest;
};

export type AddProjectJwksResponse = JWKSCreationOperation;

export type DeleteProjectJwksData = {
    /**
     * The JWKS ID
     */
    jwksId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectJwksResponse = JWKS;

export type GetConnectionUriData = {
    /**
     * The branch ID. Defaults to your project's default `branch_id` if not specified.
     */
    branchId?: string;
    /**
     * The database name
     */
    databaseName: string;
    /**
     * The endpoint ID. Defaults to the read-write `endpoint_id` associated with the `branch_id` if not specified.
     */
    endpointId?: string;
    /**
     * Adds the `-pooler` option to the connection URI when set to `true`, creating a pooled connection URI.
     */
    pooled?: boolean;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The role name
     */
    roleName: string;
};

export type GetConnectionUriResponse = ConnectionURIResponse;

export type ListProjectVpcEndpointsData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectVpcEndpointsResponse = VPCEndpointsResponse;

export type AssignProjectVpcEndpointData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: VPCEndpointAssignment;
    /**
     * The VPC endpoint ID
     */
    vpcEndpointId: string;
};

export type AssignProjectVpcEndpointResponse = unknown;

export type DeleteProjectVpcEndpointData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The VPC endpoint ID
     */
    vpcEndpointId: string;
};

export type DeleteProjectVpcEndpointResponse = unknown;

export type CreateProjectIdentityIntegrationData = {
    requestBody: IdentityCreateIntegrationRequest;
};

export type CreateProjectIdentityIntegrationResponse = IdentityCreateIntegrationResponse;

export type CreateProjectIdentityAuthProviderSdkKeysData = {
    requestBody: IdentityCreateAuthProviderSDKKeysRequest;
};

export type CreateProjectIdentityAuthProviderSdkKeysResponse = IdentityCreateIntegrationResponse;

export type TransferProjectIdentityAuthProviderProjectData = {
    requestBody: IdentityTransferAuthProviderProjectRequest;
};

export type TransferProjectIdentityAuthProviderProjectResponse = IdentityTransferAuthProviderProjectResponse;

export type ListProjectIdentityIntegrationsData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectIdentityIntegrationsResponse2 = ListProjectIdentityIntegrationsResponse;

export type DeleteProjectIdentityIntegrationData = {
    /**
     * The authentication provider name
     */
    authProvider: IdentitySupportedAuthProvider;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectIdentityIntegrationResponse = unknown;

export type CreateProjectBranchData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody?: BranchCreateRequest & AnnotationCreateValueRequest;
};

export type CreateProjectBranchResponse = BranchResponse & EndpointsResponse & OperationsResponse & RolesResponse & DatabasesResponse & ConnectionURIsOptionalResponse;

export type ListProjectBranchesData = {
    /**
     * A cursor to use in pagination. A cursor defines your place in the data list. Include `response.pagination.next` in subsequent API calls to fetch next page of the list.
     */
    cursor?: string;
    /**
     * The maximum number of records to be returned in the response
     */
    limit?: number;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * Search by branch `name` or `id`. You can specify partial `name` or `id` values to filter results.
     */
    search?: string;
    /**
     * Sort the branches by sort_field. If not provided, branches will be sorted by updated_at descending order
     */
    sortBy?: 'name' | 'created_at' | 'updated_at';
    /**
     * Defines the sorting order of entities.
     */
    sortOrder?: 'asc' | 'desc';
};

export type ListProjectBranchesResponse = BranchesResponse & AnnotationsMapResponse & CursorPaginationResponse;

export type CountProjectBranchesData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * Count branches matching the `name` in search query
     */
    search?: string;
};

export type CountProjectBranchesResponse = BranchesCountResponse;

export type GetProjectBranchData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectBranchResponse = BranchResponse & AnnotationResponse;

export type DeleteProjectBranchData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectBranchResponse = BranchOperations | void;

export type UpdateProjectBranchData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: BranchUpdateRequest;
};

export type UpdateProjectBranchResponse = BranchOperations;

export type RestoreProjectBranchData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: BranchRestoreRequest;
};

export type RestoreProjectBranchResponse = BranchOperations;

export type GetProjectBranchSchemaData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * Name of the database for which the schema is retrieved
     */
    dbName: string;
    /**
     * The Log Sequence Number (LSN) for which the schema is retrieved
     *
     */
    lsn?: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The point in time for which the schema is retrieved
     *
     */
    timestamp?: string;
};

export type GetProjectBranchSchemaResponse = BranchSchemaResponse;

export type GetProjectBranchSchemaComparisonData = {
    /**
     * The branch ID to compare the schema with
     */
    baseBranchId?: string;
    /**
     * The Log Sequence Number (LSN) for the base branch schema
     *
     */
    baseLsn?: string;
    /**
     * The point in time for the base branch schema
     *
     */
    baseTimestamp?: string;
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * Name of the database for which the schema is retrieved
     */
    dbName: string;
    /**
     * The Log Sequence Number (LSN) for which the schema is retrieved
     *
     */
    lsn?: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The point in time for which the schema is retrieved
     *
     */
    timestamp?: string;
};

export type GetProjectBranchSchemaComparisonResponse = BranchSchemaCompareResponse;

export type SetDefaultProjectBranchData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type SetDefaultProjectBranchResponse = BranchOperations;

export type ListProjectBranchEndpointsData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectBranchEndpointsResponse = EndpointsResponse;

export type ListProjectBranchDatabasesData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectBranchDatabasesResponse = DatabasesResponse;

export type CreateProjectBranchDatabaseData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: DatabaseCreateRequest;
};

export type CreateProjectBranchDatabaseResponse = DatabaseOperations;

export type GetProjectBranchDatabaseData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The database name
     */
    databaseName: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectBranchDatabaseResponse = DatabaseResponse;

export type UpdateProjectBranchDatabaseData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The database name
     */
    databaseName: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: DatabaseUpdateRequest;
};

export type UpdateProjectBranchDatabaseResponse = DatabaseOperations;

export type DeleteProjectBranchDatabaseData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The database name
     */
    databaseName: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectBranchDatabaseResponse = DatabaseOperations | void;

export type ListProjectBranchRolesData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectBranchRolesResponse = RolesResponse;

export type CreateProjectBranchRoleData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: RoleCreateRequest;
};

export type CreateProjectBranchRoleResponse = RoleOperations;

export type GetProjectBranchRoleData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The role name
     */
    roleName: string;
};

export type GetProjectBranchRoleResponse = RoleResponse;

export type DeleteProjectBranchRoleData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The role name
     */
    roleName: string;
};

export type DeleteProjectBranchRoleResponse = RoleOperations | void;

export type GetProjectBranchRolePasswordData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The role name
     */
    roleName: string;
};

export type GetProjectBranchRolePasswordResponse = RolePasswordResponse;

export type ResetProjectBranchRolePasswordData = {
    /**
     * The branch ID
     */
    branchId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    /**
     * The role nam
     */
    roleName: string;
};

export type ResetProjectBranchRolePasswordResponse = RoleOperations;

export type CreateProjectEndpointData = {
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: EndpointCreateRequest;
};

export type CreateProjectEndpointResponse = EndpointOperations;

export type ListProjectEndpointsData = {
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type ListProjectEndpointsResponse = EndpointsResponse;

export type GetProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type GetProjectEndpointResponse = EndpointResponse;

export type DeleteProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type DeleteProjectEndpointResponse = EndpointOperations | void;

export type UpdateProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
    requestBody: EndpointUpdateRequest;
};

export type UpdateProjectEndpointResponse = EndpointOperations;

export type StartProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type StartProjectEndpointResponse = EndpointOperations;

export type SuspendProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type SuspendProjectEndpointResponse = EndpointOperations;

export type RestartProjectEndpointData = {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The Neon project ID
     */
    projectId: string;
};

export type RestartProjectEndpointResponse = EndpointOperations;

export type GetConsumptionHistoryPerAccountData = {
    /**
     * Specify the start `date-time` for the consumption period.
     * The `date-time` value is rounded according to the specified `granularity`.
     * For example, `2024-03-15T15:30:00Z` for `daily` granularity will be rounded to `2024-03-15T00:00:00Z`.
     * The specified `date-time` value must respect the specified granularity:
     * - For `hourly`, consumption metrics are limited to the last 168 hours.
     * - For `daily`, consumption metrics are limited to the last 60 days.
     * - For `monthly`, consumption metrics are limited to the past year.
     *
     * The consumption history is available starting from `March 1, 2024, at 00:00:00 UTC`.
     *
     */
    from: string;
    /**
     * Specify the granularity of consumption metrics.
     * Hourly, daily, and monthly metrics are available for the last 168 hours, 60 days,
     * and 1 year, respectively.
     *
     */
    granularity: ConsumptionHistoryGranularity;
    /**
     * Include metrics utilized in previous pricing models.
     * - **data_storage_bytes_hour**: The sum of the maximum observed storage values for each hour
     * for each project, which never decreases.
     *
     */
    includeV1Metrics?: boolean;
    /**
     * Specify the organization for which the consumption metrics should be returned.
     * If this parameter is not provided, the endpoint will return the metrics for the
     * authenticated user's account.
     *
     */
    orgId?: string;
    /**
     * Specify the end `date-time` for the consumption period.
     * The `date-time` value is rounded according to the specified granularity.
     * For example, `2024-03-15T15:30:00Z` for `daily` granularity will be rounded to `2024-03-15T00:00:00Z`.
     * The specified `date-time` value must respect the specified granularity:
     * - For `hourly`, consumption metrics are limited to the last 168 hours.
     * - For `daily`, consumption metrics are limited to the last 60 days.
     * - For `monthly`, consumption metrics are limited to the past year.
     *
     */
    to: string;
};

export type GetConsumptionHistoryPerAccountResponse = ConsumptionHistoryPerAccountResponse;

export type GetConsumptionHistoryPerProjectData = {
    /**
     * Specify the cursor value from the previous response to get the next batch of projects.
     */
    cursor?: string;
    /**
     * Specify the start `date-time` for the consumption period.
     * The `date-time` value is rounded according to the specified `granularity`.
     * For example, `2024-03-15T15:30:00Z` for `daily` granularity will be rounded to `2024-03-15T00:00:00Z`.
     * The specified `date-time` value must respect the specified `granularity`:
     * - For `hourly`, consumption metrics are limited to the last 168 hours.
     * - For `daily`, consumption metrics are limited to the last 60 days.
     * - For `monthly`, consumption metrics are limited to the last year.
     *
     * The consumption history is available starting from `March 1, 2024, at 00:00:00 UTC`.
     *
     */
    from: string;
    /**
     * Specify the granularity of consumption metrics.
     * Hourly, daily, and monthly metrics are available for the last 168 hours, 60 days,
     * and 1 year, respectively.
     *
     */
    granularity: ConsumptionHistoryGranularity;
    /**
     * Include metrics utilized in previous pricing models.
     * - **data_storage_bytes_hour**: The sum of the maximum observed storage values for each hour,
     * which never decreases.
     *
     */
    includeV1Metrics?: boolean;
    /**
     * Specify a value from 1 to 100 to limit number of projects in the response.
     */
    limit?: number;
    /**
     * Specify the organization for which the project consumption metrics should be returned.
     * If this parameter is not provided, the endpoint will return the metrics for the
     * authenticated user's projects.
     *
     */
    orgId?: string;
    /**
     * Specify a list of project IDs to filter the response.
     * If omitted, the response will contain all projects.
     * A list of project IDs can be specified as an array of parameter values or as a comma-separated list in a single parameter value.
     * - As an array of parameter values: `project_ids=cold-poetry-09157238%20&project_ids=quiet-snow-71788278`
     * - As a comma-separated list in a single parameter value: `project_ids=cold-poetry-09157238,quiet-snow-71788278`
     *
     */
    projectIds?: Array<(string)>;
    /**
     * Specify the end `date-time` for the consumption period.
     * The `date-time` value is rounded according to the specified granularity.
     * For example, `2024-03-15T15:30:00Z` for `daily` granularity will be rounded to `2024-03-15T00:00:00Z`.
     * The specified `date-time` value must respect the specified `granularity`:
     * - For `hourly`, consumption metrics are limited to the last 168 hours.
     * - For `daily`, consumption metrics are limited to the last 60 days.
     * - For `monthly`, consumption metrics are limited to the last year.
     *
     */
    to: string;
};

export type GetConsumptionHistoryPerProjectResponse = ConsumptionHistoryPerProjectResponse & PaginationResponse;

export type GetOrganizationData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type GetOrganizationResponse = Organization;

export type ListOrgApiKeysData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type ListOrgApiKeysResponse = Array<OrgApiKeysListResponseItem>;

export type CreateOrgApiKeyData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    requestBody: OrgApiKeyCreateRequest;
};

export type CreateOrgApiKeyResponse = OrgApiKeyCreateResponse;

export type RevokeOrgApiKeyData = {
    /**
     * The API key ID
     */
    keyId: number;
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type RevokeOrgApiKeyResponse = OrgApiKeyRevokeResponse;

export type GetOrganizationMembersData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type GetOrganizationMembersResponse = OrganizationMembersResponse;

export type GetOrganizationMemberData = {
    /**
     * The Neon organization member ID
     */
    memberId: string;
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type GetOrganizationMemberResponse = Member;

export type UpdateOrganizationMemberData = {
    /**
     * The Neon organization member ID
     */
    memberId: string;
    /**
     * The Neon organization ID
     */
    orgId: string;
    requestBody: OrganizationMemberUpdateRequest;
};

export type UpdateOrganizationMemberResponse = Member;

export type RemoveOrganizationMemberData = {
    /**
     * The Neon organization member ID
     */
    memberId: string;
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type RemoveOrganizationMemberResponse = EmptyResponse;

export type GetOrganizationInvitationsData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
};

export type GetOrganizationInvitationsResponse = OrganizationInvitationsResponse;

export type CreateOrganizationInvitationsData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    requestBody: OrganizationInvitesCreateRequest;
};

export type CreateOrganizationInvitationsResponse = OrganizationInvitationsResponse;

export type TransferProjectsFromOrgToOrgData = {
    requestBody: TransferProjectsToOrganizationRequest;
    /**
     * The Neon organization ID (source org, which currently owns the project)
     */
    sourceOrgId: string;
};

export type TransferProjectsFromOrgToOrgResponse = EmptyResponse;

export type ListOrganizationVpcEndpointsData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    /**
     * The Neon region ID
     */
    regionId: string;
};

export type ListOrganizationVpcEndpointsResponse = VPCEndpointsResponse;

export type GetOrganizationVpcEndpointDetailsData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    /**
     * The Neon region ID.
     * Azure regions are currently not supported.
     *
     */
    regionId: string;
    /**
     * The VPC endpoint ID
     */
    vpcEndpointId: string;
};

export type GetOrganizationVpcEndpointDetailsResponse = VPCEndpointDetails;

export type AssignOrganizationVpcEndpointData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    /**
     * The Neon region ID.
     * Azure regions are currently not supported.
     *
     */
    regionId: string;
    requestBody: VPCEndpointAssignment;
    /**
     * The VPC endpoint ID
     */
    vpcEndpointId: string;
};

export type AssignOrganizationVpcEndpointResponse = unknown;

export type DeleteOrganizationVpcEndpointData = {
    /**
     * The Neon organization ID
     */
    orgId: string;
    /**
     * The Neon region ID.
     * Azure regions are currently not supported.
     *
     */
    regionId: string;
    /**
     * The VPC endpoint ID
     */
    vpcEndpointId: string;
};

export type DeleteOrganizationVpcEndpointResponse = unknown;

export type GetCurrentUserOrganizationsResponse = OrganizationsResponse;

export type GetActiveRegionsResponse = ActiveRegionsResponse;

export type GetCurrentUserInfoResponse = CurrentUserInfoResponse;

export type TransferProjectsFromUserToOrgData = {
    requestBody: TransferProjectsToOrganizationRequest;
};

export type TransferProjectsFromUserToOrgResponse = EmptyResponse;